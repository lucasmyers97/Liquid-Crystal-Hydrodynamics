"""
This program tests the finite difference methods found in the 
FiniteDifference.py module. Right now functions are hardcoded, but soon they
will be able to be programatically generated by sympy.

Lucas Myers
Written: July 15, 2020
"""

import unittest

import numpy as np
import src.FiniteDifference as fd

class TestFiniteDifferenceMethods(unittest.TestCase):
    
    def test_dx2(self):
        """
        Tests the `dx2` finite difference method in `FiniteDifference.py`. This
        Calculates the second partial derivative with respect to x. Just
        tests `cos(mx)*sin(ny)` on a few different domains with a few different
        grid spacings. Note that it is necessary to have the x-derivative of
        this function be zero at the x-boundaries. 
        """
        
        # Function and its analytic derivative to test against finite diff
        # Derivative needs to be zero at endpoints for this test
        def f1(x, y, m=1, n=1):
            return np.cos(m*x)*np.sin(n*y)
        def d2x_f1(x, y, m=1, n=1):
            return -m**2*np.cos(m*x)*np.sin(n*y)
        
        n_list = [10, 50, 100, 1000]
        length_list = [2*np.pi, 4*np.pi, 16*np.pi, 32*np.pi]
        
        for n in n_list:
            for length in length_list:
                x_domain = [-length, length]
                y_domain = [-length, length]
                
                x = np.linspace(x_domain[0], x_domain[1], num=n)
                y = np.linspace(y_domain[0], y_domain[1], num=n)
                X, Y = np.meshgrid(x, y, indexing='ij')
                dx = X[1, 0] - X[0, 0]
        
                error = np.abs( d2x_f1(X, Y) - fd.dx2(f1(X, Y), dx) )
                rel_error = error/np.mean(np.abs(d2x_f1(X, Y)))
                
                self.assertTrue(np.max(rel_error) < dx)
                
    def test_dy2(self):
        """
        Tests the `dy2` finite difference method in `FiniteDifference.py`. This
        Calculates the second partial derivative with respect to y. Just
        tests `sin(mx)*cos(ny)` on a few different domains with a few different
        grid spacings. Note that it is necessary to have the y-derivative of
        this function be zero at the y-boundaries. 
        """
        
        # Function and its analytic derivative to test against finite diff
        # Derivative needs to be zero at endpoints for this test
        def f1(x, y, m=1, n=1):
            return np.sin(m*x)*np.cos(n*y)
        def d2y_f1(x, y, m=1, n=1):
            return -n**2*np.sin(m*x)*np.cos(n*y)
        
        n_list = [10, 50, 100, 1000]
        length_list = [2*np.pi, 4*np.pi, 16*np.pi, 32*np.pi]
        
        for n in n_list:
            for length in length_list:
                x_domain = [-length, length]
                y_domain = [-length, length]
                
                x = np.linspace(x_domain[0], x_domain[1], num=n)
                y = np.linspace(y_domain[0], y_domain[1], num=n)
                X, Y = np.meshgrid(x, y, indexing='ij')
                dy = X[1, 0] - X[0, 0]
        
                error = np.abs( d2y_f1(X, Y) - fd.dy2(f1(X, Y), dy) )
                rel_error = error/np.mean(np.abs(d2y_f1(X, Y)))
                
                self.assertTrue(np.max(rel_error) < dy)
                
if __name__ == '__main__':
    unittest.main()